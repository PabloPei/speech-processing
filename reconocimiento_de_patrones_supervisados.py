# -*- coding: utf-8 -*-
"""Practica_Reconocimiento_de_Patrones_Supervisados.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-5asDausz3VYkFXSuOjG2nUzytHzz7LX
"""

import matplotlib.pyplot as plt
from matplotlib import patches
import numpy as np
import scipy
import numpy.fft as ft
from scipy import signal as sig
from scipy import io
import scipy.io.wavfile as wav
from math import *
import IPython.display as ipd
from scipy.linalg import toeplitz
from scipy import stats as sps
from mpl_toolkits.mplot3d.axes3d import Axes3D, get_test_data

"""# Ejercicio:

##Hacer un algoritmo de reconocimiento supervisado que distinga entre tres vocales

#### Recupero muchas muestras de formantes de las tres vocales y elimino la tercera columna porque voy a trabajar en dos variables
"""

data_a1 = np.loadtxt('./a.txt')
data_o1 = np.loadtxt('./o.txt')
data_u1 = np.loadtxt('./u.txt')

data_a = np.delete(data_a1, 2, axis=1)
data_o = np.delete(data_o1, 2, axis=1)
data_u = np.delete(data_u1, 2, axis=1)

formante_a1 = data_a[:,0]
formante_a2 = data_a[:,1]
formante_o1 = data_o[:,0]
formante_o2 = data_o[:,1]
formante_u1 = data_u[:,0]
formante_u2 = data_u[:,1]
plt.scatter(formante_a1, formante_a2, alpha = 0.5, color = 'blue')
plt.scatter(formante_o1, formante_o2, alpha = 0.5, color = 'red')
plt.scatter(formante_u1, formante_u2, alpha = 0.5, color = 'green')
plt.xlabel("Frecuencia 1")
plt.ylabel("Frecuencia 2")
plt.grid()
plt.show()

"""#### Defino el conjunto de entrenamiento ordenando el array al azar y me quedo con los primeros 35 valores, los otros 15 los dejo para prueba"""

def training(data):
  Na = data.shape[0]
  inda = list(np.random.permutation(range(Na)))
  conj_entrn = data[inda[0:35], :]
  conj_prueb = data[inda[35:50],:]
  return [conj_entrn, conj_prueb]

[conjunto_entrenamiento_a, conjunto_prueba_a] = training(data_a)
[conjunto_entrenamiento_o, conjunto_prueba_o] = training(data_o)
[conjunto_entrenamiento_u, conjunto_prueba_u] = training(data_u)

"""#### Calculo la media y la Matriz de covarianca"""

def medvar(entr):
  media = np.mean(entr, axis=0)
  var = np.cov(entr, rowvar=False)
  return [media, var]

[media_entr_a, cov_entr_a] = medvar(conjunto_entrenamiento_a)
[media_entr_o, cov_entr_o] = medvar(conjunto_entrenamiento_o)
[media_entr_u, cov_entr_u] = medvar(conjunto_entrenamiento_u)

"""#### Grafico las curvas de nivel"""

for i in range(3):
  u1 = (i+1)*np.cos(np.arange(0,2*pi,0.01))
  u2 = (i+1)*np.sin(np.arange(0,2*pi,0.01))

  A_menos1 = np.linalg.cholesky(cov_entr_a)
  V_a = np.transpose(A_menos1.dot(np.matrix([u1,u2]))) + media_entr_a

  O_menos1 = np.linalg.cholesky(cov_entr_o)
  V_o = np.transpose(O_menos1.dot(np.matrix([u1,u2])))  + media_entr_o

  U_menos1 = np.linalg.cholesky(cov_entr_u)
  V_u = np.transpose(U_menos1.dot(np.matrix([u1,u2])))  + media_entr_u

  plt.plot(V_a[:,0],V_a[:,1],'b')
  plt.plot(V_o[:,0],V_o[:,1],'r')
  plt.plot(V_u[:,0],V_u[:,1],'g')

plt.scatter(formante_a1, formante_a2, alpha = 0.5, color = 'blue')
plt.scatter(formante_o1, formante_o2, alpha = 0.5, color = 'red')
plt.scatter(formante_u1, formante_u2, alpha = 0.5, color = 'green')
plt.xlabel("Frecuencia 1")
plt.ylabel("Frecuencia 2")
plt.grid()
plt.show()

"""#### Grafico las superficies de nivel donde 0 es la vocal a, 1 es o y 2 corresponde a u"""

x1, x2 = np.meshgrid(np.arange(0, 1400, 1),np.arange(0, 2000,1)) #
rva = sps.multivariate_normal(mean = media_entr_a, cov = cov_entr_a)
rvo = sps.multivariate_normal(mean = media_entr_o, cov = cov_entr_o)
rvu = sps.multivariate_normal(mean = media_entr_u, cov = cov_entr_u)

pos = np.empty(x1.shape + (2, ))
pos[:,:,0] = x1
pos[:,:,1] = x2

ym = np.empty(x1.shape + (3,))
ym[:,:,0] = rva.pdf(pos)
ym[:,:,1] = rvo.pdf(pos)
ym[:,:,2] = rvu.pdf(pos)
fig = plt.figure()
ax = fig.gca(projection='3d')
argmax = np.argmax(ym, axis = 2)
ax.view_init(60, 30)
ax.plot_surface(x1,x2,argmax)

np.shape(argmax)

"""#### Grafico las curvas de decision"""

plt.scatter(formante_a1, formante_a2, alpha = 0.5, color = 'blue')
plt.scatter(formante_o1, formante_o2, alpha = 0.5, color = 'red')
plt.scatter(formante_u1, formante_u2, alpha = 0.5, color = 'green')
plt.contour(x1,x2,argmax)
plt.xlabel("Frecuencia 1")
plt.ylabel("Frecuencia 2")
plt.grid()
plt.show()

def prueba(formantes,valor):
  long=len(formantes[:,0])
  a = np.zeros(long)
  error=0
  for i in range(0,long):
    aux = argmax[round(formantes[i,1]), round(formantes[i,0])]
    a[i]=aux
    if (a[i] != valor):
      error = error + 1
  return [a, error]

[test_a,errores_a] = prueba(conjunto_prueba_a,0)
[test_o,errores_o]  = prueba(conjunto_prueba_o,1)
[test_u,errores_u]  = prueba(conjunto_prueba_u,2)

fig = plt.figure(figsize=(20,10))
fig.tight_layout()

plt.subplot(1,3,1)
valoresa = [len(conjunto_prueba_a[:,0]),errores_a]
label = ["A correctas","A incorrectas"]
plt.pie(valoresa, labels=label,autopct="%0.1f %%")
plt.title("Prueba de A")


plt.subplot(1,3,2)
valoreso = [len(conjunto_prueba_o[:,0]),errores_o]
label = ["O correctas","O incorrectas"]
plt.pie(valoreso, labels=label,autopct="%0.1f %%")
plt.title("Prueba de O")

plt.subplot(1,3,3)
valoresu = [len(conjunto_prueba_u[:,0]),errores_u]
label = ["U correctas","U incorrectas"]
plt.pie(valoresu, labels=label,autopct="%0.1f %%")
plt.title("Prueba de U")
plt.show()

