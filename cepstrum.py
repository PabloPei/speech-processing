# -*- coding: utf-8 -*-
"""Cepstrum.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H9Od1F_NVyYOl5lkmb_cbZqfbKaYuQct
"""

import matplotlib.pyplot as plt
from matplotlib import patches
import numpy as np
import scipy
import numpy.fft as ft
from scipy import signal as sig
from scipy import io
import scipy.io.wavfile as wav
from math import *
from scipy import signal
import IPython.display as ipd
from IPython.core.display import Javascript


import warnings;
warnings.filterwarnings('ignore', '.*do not.*', );
warnings.warn('DelftStack');
warnings.warn('Do not show this message');

"""***

# Ejercicio 2: Liftering, utilización del Cepstrum para deconvolución.

Un sistema H(z) con dos polos complejos conjugados $ρ \cdot e^{jθ}$ es excitado con un tren de deltas de duración finita

 a) Calcule el cepstrum complejo analítico tanto de la excitación $p_w(n) = \sum_{r=0}^{L}\beta ^r \cdot \delta (n - r \cdot N_p )$
 con β = 0,9999, y Np = 15, como de la respuesta impulsiva del sistema h(n) con $ro=0.8$ y $\theta =\pi / 4$

 b) Compare gráficamente el cepstrum analítico con el obtenido mediante DFT

***

* **Defino los parametros del ejercicio**
"""

ro = 0.8
theta = np.pi/4
Np = 15 #cada cuanto va a haber una delta
L = 20 #camtidad de deltas
beta = 0.9999

"""* **Calculo y comparación  del cepstrum analítico de h y del cepstrum calculado mediante DFT**"""

#parametros del filtro
a1 = -2*ro*np.cos(theta)
a2 = ro**2

cantidad_puntos = 1000
impulso = sig.unit_impulse(cantidad_puntos)
filtro=sig.lfilter([1.0],([1,a1,a2]), impulso)

#defino la H sombrero
puntos_fft = int(len(filtro))
espectro_señal = np.fft.fft(filtro , puntos_fft)
filtro_ceptstrum = 2*  np.fft.ifft(np.log(np.abs(espectro_señal)) , puntos_fft)  #el dos es porque real porque tenes la suma /2

#defino la h teorica
n=np.arange(1,cantidad_puntos+1)
filtro_teorico = 2/n * ro** n * np.cos((n*np.pi)/4)

#grafico ambas
fig = plt.figure(figsize=(10,6))
fig.tight_layout()

plt.subplot(1,1,1)
plt.stem(np.real(filtro_ceptstrum))
plt.plot(n,filtro_teorico,"r")
plt.xlim(0,50)
plt.xlabel ("Quefrency")
plt.ylabel("Amplitud")
plt.title ("Comparacion h_analítico  Vs h_fft")
plt.legend(['h_cep_analítico', 'h_cep_fft'])

"""* **Calculo y comparación del cepstrum analítico de la excitación y del cepstrum calculado mediante DFT**"""

n = np.arange(0,L*Np)
puntos_fft = 2**16

#defino la senal de entrada
exitacion = np.zeros(round(L*Np))
exitacion[(np.floor(n/Np)*Np)==n] = (beta) ** (n[np.floor(n/Np)*Np == n] / Np)

#defino el cepstrum mediante fft
espectro_exitacion = np.fft.fft(exitacion,puntos_fft)
exitacion_cepstrum_fft = 2*np.fft.ifft(np.log(np.abs(espectro_exitacion)))

#defino el cepstrum analitico
n = np.arange(0, puntos_fft)
xna = np.zeros(puntos_fft)
xnb = np.zeros(puntos_fft)

xna[(np.floor(n/Np)*Np)==n] = ((beta) ** (n[np.floor(n/Np)*Np == n]/Np)/n[np.floor(n/Np)*Np == n])*Np
xnb[(np.floor(n/(Np*L))*L*Np)==n] = (-(beta**L) ** (n[(np.floor(n/(L*Np))*L*Np) == n]/(Np*L)) / n[(np.floor(n/(L*Np))*L*Np) == n])*Np*L
exitacion_cepstrum_ana = xnb + xna

#grafico ambas
fig = plt.figure(figsize=(20,10))
fig.tight_layout()

plt.subplot(1,2,1)
plt.plot(exitacion_cepstrum_fft,'g')
plt.xlim(0,round(puntos_fft/2))
plt.ylabel("Amplitud")
plt.xlabel ("Quefrency")
plt.title("Cepstrum de la excitación mediante fft")

plt.subplot(1,2,2)
plt.plot(exitacion_cepstrum_ana)
plt.title("Cepstrum analitico de la excitación")
plt.ylabel("Amplitud")
plt.xlabel ("Quefrency")
plt.xlim(0,round(puntos_fft/2));

"""***

# Ejercicio 3: Implementación del cepstrum de una vocal sintética

a) Generar la señal correspondiente a los parámetros de pares de polos complejos conjugados y de radicación labial dados en el enunciado de la guía. Utilizar una p_w(n) con un $\beta=0.99999$
como en el ejercicio 2, de la longitud necesaria para obtener 0.5seg de señal.

 b) Dibujar el espectro de la señal, y superpuesto la respuesta en frecuencia del sistema (escalado).


c) Verificar que los picos de la respuesta en frecuencia (formantes) corresponden a los datos del enunciado.

***

* **Defino los parametros del ejercicio**
"""

Fo=125
Fs=16000
T=1/Fs
Fk=[660,1720,2410,3500,4500]
sigmak=[60,100,120,175,250]
duracion = 0.5 #en segundos
Np = Fs/Fo #cada cuanto una delta
L = round ((duracion * Fs)/Np) #cantidad de deltas
beta = 0.9999
puntos_fft = 2**16

"""* **Modelo del tracto vocal**"""

#Defino el modelo del tracto vocal V(z)
def tracto_vocal(entrada):

  salida=entrada
  cantidad_polos = 5

  for i in range (cantidad_polos):
    a1 = -2*np.exp(-2*np.pi*sigmak[i]*T)*np.cos(2*np.pi*Fk[i]*T)
    a2 = np.exp(-4*np.pi*sigmak[i]*T)
    salida=sig.lfilter([1.0],([1,a1,a2]), salida)

  return salida

#grafico el espectro del tracto vocal
cantidad_puntos = 1000
impulso = sig.unit_impulse(cantidad_puntos)

tracto_voc=tracto_vocal(impulso)
espectro_tracto_vocal = np.fft.fft(tracto_voc , puntos_fft)
freq = np.arange(puntos_fft)/puntos_fft*Fs

fig = plt.figure(figsize=(10,6))
fig.tight_layout()
plt.subplot(1,1,1)
plt.ylabel("Amplitud")
plt.xlabel ("Frecuencia (Hz)")
plt.plot(freq,np.abs(espectro_tracto_vocal))
plt.title("Espectro del modelo de tracto vocal");

"""* **Modelo de radiación labial**"""

#Defino el modelo de radiacion labial R(Z)
def radiacion_labial(entrada):
  salida = sig.lfilter([1.0,-0.96],[1.0],entrada)
  return salida

#grafico el espectro de la radiacion labial
radiacion_lab=radiacion_labial(impulso)
espectro_radiacion_labial = np.fft.fft(radiacion_lab , puntos_fft)

freq = np.arange(puntos_fft)/puntos_fft*Fs
fig = plt.figure(figsize=(10,6))
fig.tight_layout()
plt.subplot(1,1,1)
plt.ylabel("Amplitud")
plt.xlabel ("Frecuencia (Hz)")
plt.plot(freq,np.abs(espectro_radiacion_labial))
plt.title("Espectro del modelo de radiación labial");

"""* **Modelo del Filtro**"""

def filtro(entrada):
  salida_aux = tracto_vocal(entrada)
  salida = radiacion_labial(salida_aux)
  return salida

"""* **Defino la excitación del sistema**"""

#Defino la entrada
cantidad_muestras=round(duracion*Fs)
cantidad_zeros=8000
n = np.arange(0,cantidad_muestras)
zeros = np.zeros(cantidad_zeros)

exitacion_aux = np.zeros(cantidad_muestras)
exitacion_aux[(np.floor(n/Np)*Np)==n] = (beta) ** (n[np.floor(n/Np)*Np == n] / Np)
exitacion = np.append(exitacion_aux, zeros)

tiempo = np.arange(0, duracion + cantidad_zeros/Fs, 1/Fs);

fig = plt.figure(figsize=(10,6))
fig.tight_layout()

plt.subplot(1,1,1)
plt.plot(tiempo,exitacion)
plt.ylabel("Amplitud")
plt.xlabel ("Tiempo (s)")
plt.title("Excitación en la entrada del sistema");

"""* **Conformo la señal de salida del sistema y la comparo con la respuesta en frecuencia del sistema escalado**"""

#conformo mi señal de salida

senal_salida = filtro(exitacion)
espectro_senal_salida=np.fft.fft(senal_salida,puntos_fft)
freq = np.arange(puntos_fft)/puntos_fft*Fs

#conformo el filtro escalado
cantidad_puntos = 1000
impulso = sig.unit_impulse(cantidad_puntos)
senal_filtro=filtro(impulso)
espectro_senal_filtro = np.fft.fft(senal_filtro , puntos_fft)
freq = np.arange(puntos_fft)/puntos_fft*Fs

#grafico
fig = plt.figure(figsize=(10,6))
fig.tight_layout()
plt.subplot(1,1,1)
plt.plot(freq,np.abs(espectro_senal_salida))
plt.plot(freq,np.abs(espectro_senal_filtro) * 62,'g')
plt.ylabel("Amplitud")
plt.xlabel ("Frecuencia (Hz)")
plt.title("Señal de salida del sistema Vs Respuesta en frecuencia del sistema escalado")
plt.legend(['Salida del sistema', 'Respuesta en frecuencia del filtro escalado'])
plt.xlim(0,Fs/2);

"""* **Señal de audio**"""

ipd.Audio(senal_salida,rate=Fs)

"""* **Cepstrum complejo de la señal de salida**"""

#defino el cepstrum complejo
salida_cepstrum = 2*np.fft.ifft(np.log(np.abs(espectro_senal_salida)))

#grafico
fig = plt.figure(figsize=(10,6))
fig.tight_layout()
plt.subplot(1,1,1)
plt.plot(np.real(salida_cepstrum))
plt.ylabel("Amplitud")
plt.xlabel ("Quefrency")
plt.title("Cepstrum complejo de la señal")
plt.xlim(0,1000);

"""***

#Ejercicio 4: Liftering, comparación con el espectro real.

Utilizar el cepstrum real calculado por DFT y liftering para obtener la envolvente del espectro.

a) Calcular el cepstrum real de la señal generada en el ejercicio anterior utilizando DFT y grafíquelo para determinar el ancho de la ventana de liftering necesaria para obtener el espectro de la envolvente. Compare con la verdadera envolvente.

b) Para la señal fantasia.wav, ejecute el cálculo anterior de recuperar el espectro de la envolvente por cepstrum y liftering sobre ventanas de señal superpuestas parcialmente del mismo modo que en el caso de LPC de la práctica anterior. Luego grafique las envolventes como una superficie. Comparar con el gráfico obtenido por LPC.

***

* **Defino la funcion de liftering**
"""

def liftering (x):
  h_cepstrum = x[0:round(Np)] #me quedo con la parte baja del cepstrum antes de que aparezca la primer delta que es el h
  mod_H = np.abs(np.exp(np.fft.fft(h_cepstrum,puntos_fft)))
  return mod_H

"""* **Aplico el liftering al cepstrum de la señal, luego le calculo la fft y por ultimo la exponencial**"""

#grafico el |H(w)| recuperado por liftering del cepstrum

mod_H=liftering(salida_cepstrum)  #la radiacion labial me da ruido

#grafico el |H(w)| real sin la radiacion labial
cantidad_imp = 1000
impulso = sig.unit_impulse(cantidad_imp)
rta_filtro=filtro(impulso)
espectro_rta_filtro=np.fft.fft(rta_filtro,puntos_fft)

#grafico
freq = np.arange(puntos_fft)/puntos_fft*Fs
fig = plt.figure(figsize=(10,6))
fig.tight_layout()
plt.subplot(1,1,1)
plt.plot(freq,mod_H)
plt.plot(freq,np.abs(espectro_rta_filtro))
plt.ylabel("Amplitud")
plt.xlabel ("Frecuencia [Hz]")
plt.title("Comparación entre H calculada y liftering")
plt.legend(['H_litering','H_calculada']);

"""* **Recupero la función fantasia**"""

# Commented out IPython magic to ensure Python compatibility.
# Carga de los valores numéricos de la señal
# %cd /content
(Fs,fantasia) = wav.read('fantasia.wav')
fantasia = fantasia.astype(float)/32767

W = round(0.025*Fs);
D = round(0.010*Fs);

ipd.Audio(fantasia,rate=Fs)

tiempo = np.arange(0, len(fantasia)/Fs, 1/Fs)
freq1 = np.linspace(0,Fs, puntos_fft, endpoint=0,);

espectro_fantasia = np.fft.fft(fantasia,puntos_fft)
fig = plt.figure(figsize=(20,10))
plt.subplot(1,2,1)
plt.plot(tiempo,fantasia)
plt.title("Senal fantasia")
plt.xlabel("Tiempo (s)")
plt.ylabel("Amplitud")

plt.subplot(1,2,2)
plt.plot(freq1,np.real(espectro_fantasia),'g')
plt.xlim(0,Fs/2)
plt.title("Espectro senal fantasia")
plt.xlabel("Frecuencia")
plt.ylabel("Amplitud");

"""* **Obtengo la envolvente como una superficie con LPC**"""

#####FUNCION PARA CALCULAR LOS COEFICIENTES DEL LPC########

def funcionlpc(# Ventana de señal
    senial_w,
    #Cantidad de coeficientes,
    cantidad_coef
    ):

  #defino la correlacion
    corr = signal.correlate (senial_w , senial_w , 'full', 'direct' )

  #busco los 20 coeficientes
    cero_cor = round(len(corr)/2) -1
    Ros = corr[cero_cor: cero_cor+cantidad_coef +1]

  #defino a y b
    A = scipy.linalg.toeplitz(Ros[0:cantidad_coef])
    b = Ros[1:cantidad_coef+1]

  #Busco los coeficientes
    alpha = np.dot(np.linalg.inv(A), b)

  #Busco G
    G = np.sqrt(Ros[0] - np.dot(np.transpose(b),alpha))

    return [alpha,G]

cantidad_coef = 20;

Lpasos =  round((len(fantasia) - W)/D);
#Inicializar ai
ai = np.zeros(cantidad_coef);

# Almaceno los coeficientes del filtro en una matriz [cantidad pasos, cantidad puntos]
matriz_espectros_lpc = [];

for n in range(Lpasos):
    [ai,G]  = funcionlpc(fantasia[(n*D):(n*D)+W],cantidad_coef);
    imp = sig.unit_impulse(cantidad_puntos)
    IIR = sig.lfilter([G],np.concatenate(([1],-ai)), imp)
    espectro_senal = np.fft.fft(IIR)
    matriz_espectros_lpc.append(np.log10(abs(espectro_senal)))

"""* **Recupero el espectro de la envolvente por cepstrum y liftering sobre ventanas de señal superpuestas parcialmente**

"""

def cepstrum(entrada):

  salida = filtro(entrada)

  fft_salida = np.fft.fft(salida, puntos_fft)

  cepstrum_salida= 2*np.fft.ifft(np.log(np.abs(fft_salida)))

  liftering_salida=liftering(cepstrum_salida)

  return liftering_salida

liftering_aux = np.zeros(puntos_fft);

# For para almacenar los coeficientes ai en una matriz
matriz_espectros_cepstrum = [];
for n in range(int(Lpasos)):
    liftering_aux  = cepstrum(fantasia[(n*D):(n*D)+W]);
    matriz_espectros_cepstrum.append(np.log10(abs(liftering_aux)))

"""* **Grafico ambas envolventes como superficies y el espectrograma de la señal fantasia para compararlas**"""

#con la matriz obtenida grafico un espectrograma del filtro que me permite ver los fonemas
tiempo = np.linspace(0, len(fantasia)/Fs, int(Lpasos))

freq1 = np.linspace(0,Fs, puntos_fft, endpoint=0,);
fig = plt.figure(figsize=(24,10))
fig.tight_layout()
plt.subplot(1,3,1)
plt.pcolormesh(tiempo, freq1, np.transpose(matriz_espectros_cepstrum))
plt.ylim(0,Fs/2)
plt.title("Espectro - Cepstrum")
plt.xlabel("Tiempo (s)")
plt.ylabel("Frecuencia (Hz)")

plt.subplot(1,3,2)
freq = np.linspace(0,Fs,cantidad_puntos, endpoint=0,);
plt.pcolormesh(tiempo,freq,np.transpose(matriz_espectros_lpc));
plt.ylim(0,Fs/2);
plt.title("Espectrograma LPC")
plt.xlabel("Tiempo (s)")
plt.ylabel("Frecuencia (Hz)")

plt.subplot(1,3,3)
f, t, Sxx = sig.spectrogram(fantasia, fs = Fs, window='hanning',  noverlap = 160, nperseg = 400,  mode = "psd")
plt.pcolormesh(t, f, np.log(Sxx), shading='gouraud')
plt.xlabel("Tiempo (s)")
plt.ylabel("Frecuencia (Hz)")
plt.title("Espectrograma Señal");

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# %cd /content/drive/My Drive/Colab Notebooks
# !sudo apt-get install texlive-xetex texlive-fonts-recommended texlive-plain-generic
# !jupyter nbconvert --to pdf Cepstrum.ipynb

